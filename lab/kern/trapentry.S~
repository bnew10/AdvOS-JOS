/* See COPYRIGHT for copyright information. */

#include <inc/mmu.h>
#include <inc/memlayout.h>
#include <inc/trap.h>



###################################################################
# exceptions/interrupts
###################################################################

/* TRAPHANDLER defines a globally-visible function for handling a trap.
 * It pushes a trap number onto the stack, then jumps to _alltraps.
 * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.
 *
 * You shouldn't call a TRAPHANDLER function from C, but you may
 * need to _declare_ one in C (for instance, to get a function pointer
 * during IDT setup).  You can declare the function with
 *   void NAME();
 * where NAME is the argument passed to TRAPHANDLER.
 */
#define TRAPHANDLER(name, num)						\
	.globl name;		/* define global symbol for 'name' */	\
	.type name, @function;	/* symbol type is function */		\
	.align 2;		/* align function definition */		\
	name:			/* function starts here */		\
	pushl $(num);							\
	jmp _alltraps

/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
 * It pushes a 0 in place of the error code, so the trap frame has the same
 * format in either case.
 */
#define TRAPHANDLER_NOEC(name, num)					\
	.globl name;							\
	.type name, @function;						\
	.align 2;							\
	name:								\
	pushl $0;							\
	pushl $(num);							\
	jmp _alltraps

.text

/*
 * Lab 3: Your code here for generating entry points for the different traps.
 */

	/*
Divide error                       0            No
Debug exceptions                   1            No
Breakpoint                         3            No
Overflow                           4            No
Bounds check                       5            No
Invalid opcode                     6            No
Coprocessor not available          7            No
System error                       8            Yes (always 0)
Coprocessor Segment Overrun        9            No
Invalid TSS                       10            Yes
Segment not present               11            Yes
Stack exception                   12            Yes
General protection fault          13            Yes
Page fault                        14            Yes
Coprocessor error                 16            No
Two-byte SW interrupt             0-255         No


// Trap numbers
// These are processor defined:
#define T_DIVIDE     0		// divide error
#define T_DEBUG      1		// debug exception
#define T_NMI        2		// non-maskable interrupt
#define T_BRKPT      3		// breakpoint
#define T_OFLOW      4		// overflow
#define T_BOUND      5		// bounds check
#define T_ILLOP      6		// illegal opcode
#define T_DEVICE     7		// device not available
#define T_DBLFLT     8		// double fault
 #define T_COPROC  9 	// reserved (not generated by recent processors)
#define T_TSS       10		// invalid task switch segment
#define T_SEGNP     11		// segment not present
#define T_STACK     12		// stack exception
#define T_GPFLT     13		// general protection fault
#define T_PGFLT     14		// page fault
 #define T_RES    15 	// reserved
#define T_FPERR     16		// floating point error
#define T_ALIGN     17		// aligment check
#define T_MCHK      18		// machine check
#define T_SIMDERR   19		// SIMD floating point error

// These are arbitrarily chosen, but with care not to overlap
// processor defined exceptions or interrupt vectors.
#define T_SYSCALL   48		// system call
#define T_DEFAULT   500		// catchall
*/

//TRAPHANDLER_NOEC for traps without error code
// From 0-7 no error code requred
	TRAPHANDLER_NOEC(handler_0, 0)   #Divide error
	TRAPHANDLER_NOEC(handler_1, 1)   #Debug exceptions 
 	TRAPHANDLER_NOEC(handler_2, 2)   //NMI Interrupt
	TRAPHANDLER_NOEC(handler_3, 3)   //Breakpoint
	TRAPHANDLER_NOEC(handler_4, 4)   //Overflow
	TRAPHANDLER_NOEC(handler_5, 5)   //Bounds check 
	TRAPHANDLER_NOEC(handler_6, 6)   //Invalid opcode
	TRAPHANDLER_NOEC(handler_7, 7)   //Coprocessor not available
	
	TRAPHANDLER(handler_8, 8)   // double fault
	
	TRAPHANDLER_NOEC(handler_9, 9)   //Coprocessor Segment Overrun

	TRAPHANDLER(handler_10, 10)   // invalid task switch segment
	TRAPHANDLER(handler_11, 11)   // segment not present
	TRAPHANDLER(handler_12, 12)   // stack exception
	TRAPHANDLER(handler_13, 13)   // general protection fault
	TRAPHANDLER(handler_14, 14)   // page fault

	TRAPHANDLER_NOEC(handler_15, 15)   // Reserved

	TRAPHANDLER_NOEC(handler_16, 16)   // floating point error

	TRAPHANDLER(handler_17, 17)   // aligment check

	TRAPHANDLER_NOEC(handler_18, 18)   // machine check
	TRAPHANDLER_NOEC(handler_19, 19)   // SIMD floating point error

	TRAPHANDLER_NOEC(handler_48, 48)   // system call

/*
 * Lab 3: Your code here for _alltraps
 */

.globl _alltraps
_alltraps:
	#Remaining Trap frame
	push %ds
	push %es
	pushal

	
	movw $GD_KD, %ax
	movw %ax, %ds
	movw %ax, %es

	#call Trap 
	pushl %esp
	call trap

	#restore operation
	#addl $0x04, %esp
	#popal
	#pop %es
	#pop %ds

	#addl $0x08, %esp
	#iret

.data
.global int_vector_table
int_vector_table:
	.long handler_0
	.long handler_1
	.long handler_2
	.long handler_3
	.long handler_4
	.long handler_5
	.long handler_6
	.long handler_7
	.long handler_8
	.long handler_9
	.long handler_10
	.long handler_11
	.long handler_12
	.long handler_13
	.long handler_14
	.long handler_15
	.long handler_16
	.long handler_17
	.long handler_18
	.long handler_19
	.long 20
	.long 21
	.long 22
	.long 23
	.long 24
	.long 25
	.long 26
	.long 27
	.long 28
	.long 29
	.long 30
	.long 31
	.long 32
	.long 33
	.long 34
	.long 35
	.long 36
	.long 37
	.long 38
	.long 39
	.long 40
	.long 41
	.long 42
	.long 43
	.long 44
	.long 45
	.long 46
	.long 47
	.long handler_48
	.long 49
	.long 50






 



